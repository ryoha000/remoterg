<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RemoteRG - リモートゲームプレイ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #fff;
        }
        
        .status {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .status.connected {
            background: #2a4a2a;
        }
        
        .status.error {
            background: #4a2a2a;
        }
        
        #video {
            width: 100%;
            max-width: 1280px;
            background: #000;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }
        
        button {
            padding: 12px 24px;
            background: #3a3a3a;
            color: #fff;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #4a4a4a;
        }
        
        button:active {
            background: #2a2a2a;
        }
        
        button.primary {
            background: #0066cc;
        }
        
        button.primary:hover {
            background: #0055aa;
        }
        
        .log {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        
        .info {
            background: #242424;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            white-space: pre-wrap;
            line-height: 1.5;
        }
        
        .log-entry {
            margin-bottom: 5px;
            color: #aaa;
        }
        
        .log-entry.error {
            color: #ff6666;
        }
        
        .log-entry.success {
            color: #66ff66;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>RemoteRG</h1>
        
        <div id="status" class="status">
            接続待機中...
        </div>

        <div id="videoInfo" class="info">
            pc: -
            receiver: -
            stream: -
            track: -
        </div>
        
        <video id="video" autoplay playsinline muted></video>
        
        <div class="controls">
            <button id="connectBtn" class="primary">接続</button>
            <button id="nextBtn">次へ (Enter)</button>
            <button id="screenshotBtn">スクリーンショット</button>
        </div>
        
        <div class="log" id="log"></div>
    </div>
    
    <script>
        const statusEl = document.getElementById('status');
        const videoEl = document.getElementById('video');
        const connectBtn = document.getElementById('connectBtn');
        const nextBtn = document.getElementById('nextBtn');
        const screenshotBtn = document.getElementById('screenshotBtn');
        const logEl = document.getElementById('log');
        const videoInfoEl = document.getElementById('videoInfo');
        
        let ws = null;
        let pc = null;
        let dataChannel = null;
        let remoteDescSet = false;                  // Answer適用済みか
        const pendingIceCandidates = [];            // Answer前に届いた候補の一時バッファ
        let statsIntervalId = null;                 // 受信統計のポーリング
        let frameCbCount = 0;                       // requestVideoFrameCallbackの呼び出し回数
        let candidateLogged = false;                // 選択候補のログ出力を一度だけ行う
        const urlParams = new URLSearchParams(window.location.search);
        const codecParam = (urlParams.get('codec') || 'h264').toLowerCase();

        function renderVideoDebug(extra = {}) {
            if (!videoInfoEl) return;
            const receiver = pc?.getReceivers().find(r => r.track?.kind === 'video');
            const track = receiver?.track || videoEl.srcObject?.getVideoTracks?.()[0];
            const stream = videoEl.srcObject;
            const lines = [];
            lines.push(`pc: ${pc ? 'yes' : 'no'}`);
            lines.push(`receiver: ${receiver ? receiver.transport ? 'yes (with transport)' : 'yes' : 'no'}`);
            lines.push(`stream: ${stream ? `id=${stream.id} tracks=${stream.getTracks().length}` : 'none'}`);
            if (track) {
                lines.push(`track: kind=${track.kind} id=${track.id}`);
                lines.push(`  readyState=${track.readyState} muted=${track.muted} enabled=${track.enabled}`);
                lines.push(`  contentHint=${track.contentHint || '-'}`);
            } else {
                lines.push('track: none');
            }
            if (receiver?.transport) {
                const t = receiver.transport;
                lines.push(`transport: ice=${t.iceTransport?.state ?? '-'} dtls=${t.dtlsTransport?.state ?? '-'}`);
            }
            if (extra.inbound) {
                const inbound = extra.inbound;
                lines.push(`inbound: bytes=${inbound.bytesReceived ?? '-'} frames=${inbound.framesReceived ?? '-'}`);
                lines.push(`         width=${inbound.frameWidth ?? '-'} height=${inbound.frameHeight ?? '-'} fps=${inbound.framesPerSecond ?? '-'}`);
            }
            if (extra.trackReport) {
                const tr = extra.trackReport;
                lines.push(`track stats: decoded=${tr.framesDecoded ?? '-'} dropped=${tr.framesDropped ?? '-'} freeze=${tr.freezeCount ?? '-'}`);
            }
            videoInfoEl.textContent = lines.join('\n');
        }
        
        function log(message, type = 'info') {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }
        
        function updateStatus(message, className = '') {
            statusEl.textContent = message;
            statusEl.className = `status ${className}`;
        }
        
        async function connect() {
            try {
                updateStatus('接続中...');
                log('WebSocket接続を開始...');
                
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/signal`;
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    log('WebSocket接続確立', 'success');
                    createPeerConnection();
                };
                
                ws.onmessage = async (event) => {
                    try {
                        const message = JSON.parse(event.data);
                        log(`受信: ${message.type}`);
                        
                        if (message.type === 'answer') {
                            try {
                                log(`Answer SDP (最初の100文字): ${message.sdp.substring(0, 100)}...`);
                                await pc.setRemoteDescription({
                                    type: 'answer',
                                    sdp: message.sdp
                                });
                                remoteDescSet = true;
                                log('Answerを設定', 'success');
                                log(`現在のシグナリング状態: ${pc.signalingState}`);

                                // Answer適用後に滞留ICE候補をまとめて適用
                                while (pendingIceCandidates.length > 0) {
                                    const candidate = pendingIceCandidates.shift();
                                    try {
                                        await pc.addIceCandidate(candidate);
                                        log('ICE candidate追加（バッファから）', 'success');
                                    } catch (error) {
                                        log(`ICE candidate追加エラー（バッファ）: ${error}`, 'error');
                                        console.error('addIceCandidate buffered error:', error);
                                    }
                                }
                            } catch (error) {
                                log(`Answer設定エラー: ${error}`, 'error');
                                console.error('setRemoteDescription error:', error);
                                console.error('Answer SDP:', message.sdp);
                            }
                        } else if (message.type === 'ice_candidate') {
                            try {
                                const candidateInit = {
                                    candidate: message.candidate,
                                    sdpMid: message.sdp_mid,
                                    sdpMLineIndex: message.sdp_mline_index
                                };

                                if (!remoteDescSet) {
                                    // RemoteDescription未設定ならバッファして後で適用
                                    pendingIceCandidates.push(candidateInit);
                                    log('ICE candidateをバッファに保存（Answer待ち）', 'info');
                                } else {
                                    await pc.addIceCandidate(candidateInit);
                                    log('ICE candidate追加', 'success');
                                }
                            } catch (error) {
                                log(`ICE candidate追加エラー: ${error}`, 'error');
                                console.error('addIceCandidate error:', error);
                            }
                        }
                    } catch (error) {
                        log(`メッセージ処理エラー: ${error}`, 'error');
                        console.error('Message processing error:', error);
                    }
                };
                
                ws.onerror = (error) => {
                    log(`WebSocketエラー: ${error}`, 'error');
                    updateStatus('接続エラー', 'error');
                };
                
                ws.onclose = () => {
                    log('WebSocket接続が閉じられました', 'error');
                    updateStatus('切断されました', 'error');
                };
                
            } catch (error) {
                log(`接続エラー: ${error}`, 'error');
                updateStatus('接続エラー', 'error');
            }
        }
        
        function createPeerConnection() {
            log('PeerConnectionを作成...');
            
            // ホスト側と対称的にiceServersを空配列にする（STUN不要）
            pc = new RTCPeerConnection({
                iceServers: []
            });
            
            pc.onicecandidate = (event) => {
                if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'ice_candidate',
                        candidate: event.candidate.candidate,
                        sdp_mid: event.candidate.sdpMid,
                        sdp_mline_index: event.candidate.sdpMLineIndex
                    }));
                }
            };
            
            pc.ontrack = async (event) => {
                log(`ストリームを受信 (tracks=${event.streams?.[0]?.getTracks().length ?? 0})`, 'success');
                if (event.track) {
                    log(`トラック情報 kind=${event.track.kind} id=${event.track.id} readyState=${event.track.readyState}`);
                }
                renderVideoDebug();
                
                // event.streamsが空の場合のフォールバック
                if (event.streams && event.streams.length > 0) {
                    videoEl.srcObject = event.streams[0];
                } else if (event.track) {
                    // trackから直接MediaStreamを作成
                    videoEl.srcObject = new MediaStream([event.track]);
                    log('TrackからMediaStreamを作成', 'success');
                } else {
                    log('ストリームもトラックも見つかりません', 'error');
                    return;
                }
                
                // 再生を開始（リトライ付き）
                let retryCount = 0;
                const maxRetries = 3;
                while (retryCount < maxRetries) {
                    try {
                        await videoEl.play();
                        log('動画の再生を開始', 'success');
                        updateStatus('接続済み', 'connected');

                        // 受信統計の定期取得を開始
                        startStatsLogging();

                        // フレーム到達の有無を軽く確認（多すぎないよう間引き）
                        if ('requestVideoFrameCallback' in videoEl) {
                            const frameLogger = () => {
                                frameCbCount++;
                                if (frameCbCount <= 5 || frameCbCount % 60 === 0) {
                                    log(`requestVideoFrameCallback: frame #${frameCbCount}`);
                                }
                                videoEl.requestVideoFrameCallback(frameLogger);
                            };
                            videoEl.requestVideoFrameCallback(frameLogger);
                        } else {
                            log('requestVideoFrameCallback未サポート、代わりにgetStatsのみ確認');
                        }
                renderVideoDebug();

                        break;
                    } catch (error) {
                        retryCount++;
                        if (retryCount >= maxRetries) {
                            const reason = error?.message || error?.name || `${error}`;
                            log(`動画の再生に失敗 (${maxRetries}回リトライ後): ${reason}`, 'error');
                            console.error('Video play error:', error);
                        } else {
                            log(`動画の再生リトライ ${retryCount}/${maxRetries}...`);
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                    }
                }
            };
            
            pc.onconnectionstatechange = () => {
                const state = pc.connectionState;
                log(`接続状態: ${state}`);
                if (state === 'failed' || state === 'closed') {
                    updateStatus(`接続失敗: ${state}`, 'error');
                    stopStatsLogging();
                } else if (state === 'disconnected') {
                    // disconnectedは一時的な状態の可能性があるため、警告のみ
                    log(`接続が一時的に切断されました: ${state}`, 'error');
                    updateStatus('接続が切断されました', 'error');
                } else if (state === 'connected') {
                    updateStatus('接続済み', 'connected');
                }
                renderVideoDebug();
            };
            
            pc.oniceconnectionstatechange = () => {
                const iceState = pc.iceConnectionState;
                log(`ICE接続状態: ${iceState}`);
                
                // ICE接続状態に応じてUIを更新
                if (iceState === 'connected' || iceState === 'completed') {
                    updateStatus('接続済み', 'connected');
                    startStatsLogging();
                } else if (iceState === 'failed' || iceState === 'disconnected') {
                    updateStatus(`ICE接続失敗: ${iceState}`, 'error');
                    stopStatsLogging();
                }
                renderVideoDebug();
            };
            
            pc.onicegatheringstatechange = () => {
                log(`ICE収集状態: ${pc.iceGatheringState}`);
            };
            
            pc.onsignalingstatechange = () => {
                log(`シグナリング状態: ${pc.signalingState}`);
                renderVideoDebug();
            };
            
            // Video受信用のtransceiverを追加（recvonly）
            const videoTransceiver = pc.addTransceiver('video', { direction: 'recvonly' });
            log('Video recvonly transceiverを追加', 'success');

            // codec指定: デフォルトh264。?codec=any で制約を外す
            if (codecParam === 'h264') {
                try {
                    const capabilities = RTCRtpSender.getCapabilities('video');
                    const h264Codecs = (capabilities?.codecs ?? []).filter(c =>
                        c.mimeType === 'video/H264' &&
                        (c.sdpFmtpLine ?? '').includes('packetization-mode=1')
                    );
                    if (h264Codecs.length > 0 && typeof videoTransceiver.setCodecPreferences === 'function') {
                        videoTransceiver.setCodecPreferences(h264Codecs);
                        log(`H.264 codec preferenceを適用 (${h264Codecs.length}件)`, 'success');
                    } else {
                        log('H.264 codec preferenceを設定できませんでした（対象なし/未対応ブラウザ）', 'error');
                    }
                } catch (error) {
                    log(`codec preference設定エラー: ${error}`, 'error');
                    console.error('setCodecPreferences error:', error);
                }
            } else {
                log(`codec preferenceを適用せず (codec=${codecParam})`);
            }
            
            // DataChannelを作成
            dataChannel = pc.createDataChannel('input', { ordered: true });
            dataChannel.onopen = () => {
                log('DataChannelが開きました', 'success');
            };
            dataChannel.onerror = (error) => {
                log(`DataChannelエラー: ${error}`, 'error');
            };
            
            // Offerを作成して送信
            pc.createOffer().then(async (offer) => {
                try {
                    await pc.setLocalDescription(offer);
                    log('Offerを作成して送信', 'success');
                    log(`Offer SDP (最初の100文字): ${offer.sdp.substring(0, 100)}...`);
                    
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'offer',
                            sdp: offer.sdp
                        }));
                    }
                } catch (error) {
                    log(`LocalDescription設定エラー: ${error}`, 'error');
                    console.error('setLocalDescription error:', error);
                }
            }).catch(error => {
                log(`Offer作成エラー: ${error}`, 'error');
                console.error('createOffer error:', error);
            });
        }
        
        function sendKey(key, down = true) {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({
                    type: 'key',
                    key: key,
                    down: down
                }));
                log(`キー送信: ${key} (down: ${down})`);
            } else {
                log('DataChannelが開いていません', 'error');
            }
        }
        
        function requestScreenshot() {
            if (dataChannel && dataChannel.readyState === 'open') {
                dataChannel.send(JSON.stringify({
                    type: 'screenshot_request'
                }));
                log('スクリーンショットリクエスト送信');
            } else {
                log('DataChannelが開いていません', 'error');
            }
        }

        async function startStatsLogging() {
            if (!pc) return;
            // すでにポーリング中ならスキップ
            if (statsIntervalId !== null) return;

            const receiver = pc.getReceivers().find(r => r.track?.kind === 'video');
            if (!receiver) {
                log('stats: videoレシーバーが見つかりませんでした');
                return;
            }

            // 受信パラメータ（payload typeやfmtp）を一度ログ
            try {
                const params = receiver.getParameters();
                if (params?.codecs?.length) {
                    params.codecs.forEach(c => {
                        log(`recv params codec pt=${c.payloadType} mime=${c.mimeType} fmtp=${c.sdpFmtpLine ?? ''}`);
                    });
                }
            } catch (err) {
                log(`recv params取得エラー: ${err}`, 'error');
            }

            statsIntervalId = setInterval(async () => {
                try {
                    const reports = await receiver.getStats();
                    let inbound = null;
                    let trackReport = null;
                    let selectedPair = null;
                    const allPairs = [];
                    const locals = {};
                    const remotes = {};
                    reports.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            inbound = report;
                        } else if (report.type === 'track') {
                            trackReport = report;
                        } else if (report.type === 'candidate-pair') {
                            allPairs.push(report);
                            if (report.nominated && report.state === 'succeeded') {
                                selectedPair = report;
                            }
                        } else if (report.type === 'local-candidate') {
                            locals[report.id] = report;
                        } else if (report.type === 'remote-candidate') {
                            remotes[report.id] = report;
                        }
                    });

                    if (inbound) {
                        log(`stats inbound: bytes=${inbound.bytesReceived ?? '-'} frames=${inbound.framesReceived ?? '-'} packetsLost=${inbound.packetsLost ?? '-'}`);
                    } else {
                        log('stats: inbound-rtpなし');
                    }

                    if (trackReport) {
                        log(`stats track: decoded=${trackReport.framesDecoded ?? '-'} dropped=${trackReport.framesDropped ?? '-'} freeze=${trackReport.freezeCount ?? '-'}`);
                    }

                    renderVideoDebug({ inbound, trackReport });

                    if (!candidateLogged) {
                        if (selectedPair) {
                            const localCand = locals[selectedPair.localCandidateId];
                            const remoteCand = remotes[selectedPair.remoteCandidateId];
                            log(`selected candidate: local=${localCand?.address ?? '?'}:${localCand?.port ?? '?'} (${localCand?.candidateType ?? '?'}) -> remote=${remoteCand?.address ?? '?'}:${remoteCand?.port ?? '?'} (${remoteCand?.candidateType ?? '?'}) state=${selectedPair.state}`);
                            candidateLogged = true;
                        } else if (allPairs.length) {
                            // nominatedが無い場合、最初のsucceededを参考までに出す
                            const firstSucceeded = allPairs.find(p => p.state === 'succeeded');
                            if (firstSucceeded) {
                                const localCand = locals[firstSucceeded.localCandidateId];
                                const remoteCand = remotes[firstSucceeded.remoteCandidateId];
                                log(`candidate (non-nominated): local=${localCand?.address ?? '?'}:${localCand?.port ?? '?'} (${localCand?.candidateType ?? '?'}) -> remote=${remoteCand?.address ?? '?'}:${remoteCand?.port ?? '?'} (${remoteCand?.candidateType ?? '?'}) state=${firstSucceeded.state}`);
                                candidateLogged = true;
                            }
                        }
                    }
                } catch (err) {
                    log(`stats取得エラー: ${err}`, 'error');
                }
            }, 2000);
        }

        function stopStatsLogging() {
            if (statsIntervalId !== null) {
                clearInterval(statsIntervalId);
                statsIntervalId = null;
            }
            renderVideoDebug();
        }
        
        connectBtn.addEventListener('click', connect);
        nextBtn.addEventListener('click', () => {
            sendKey('ENTER', true);
            setTimeout(() => sendKey('ENTER', false), 100);
        });
        screenshotBtn.addEventListener('click', requestScreenshot);
        
        log('初期化完了');
        renderVideoDebug();
    </script>
</body>
</html>

